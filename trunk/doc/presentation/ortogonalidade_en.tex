\section{Frequent and Orthogonal Patterns}
\subsection{Contextualizing}

\begin{frame}{Frequent Patterns}
	\begin{itemize}[<+-| alert@+>]
		\item Widely used in several applications, including association rules, classification, clustering, indexing, etc.;
		\item Minimize the result is still a challenge:
		\begin{itemize}[<+-| alert@+>]
			\item One of the properties of Frequent Patterns is anti-monotonicity.
		\end{itemize}
		\item Minimize redundancy is another challenge:
		\begin{itemize}[<+-| alert@+>]
			\item There is limited work on finding those top-k patterns which demonstrate high-significance and low-redundancy simultaneously.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Frequent Patterns}
	\begin{block}{Orthogonal Patterns}
		Our goal is to apply orthogonality in the frequent pattern mining problem, extracting a sub-set of patterns with high-significance and low-redundancy simultaneously.
	\end{block}
\end{frame}

\begin{frame}{Orthogonality Metrics}
	\begin{itemize}[<+-| alert@+>]
		\item It is necessary to define orthogonality metrics in order to evaluate sets;
		\item The Jaccard similarity coefficient complement applied to dataset coverage may be considered as an orthogonality metric applicable to two patterns: \[D(p_1,p_2) = 1 - \frac{|TS(p_1) \cap TS(p_2)|}{|TS(p_1) \cup TS(p_2)|},\] where $TS(p)$ is the set of transactions covered by $p$.
		\item We are interested in metrics applicable to sets of different sizes.
	\end{itemize}
\end{frame}

\subsection{Orthogonality Metrics}

\begin{frame}{Considering Pattern Structures}
	\begin{block}{Motivation}
		Two patterns are orthogonal if they don't share items. We say that the patterns $ABC$ and $DEF$ are orthogonal, but $ABC$ e $CDE$ are not, since the item $C$ is present in both patterns. This may be applied to bigger sets, for example, the patterns $AB$, $CD$ e $EF$ are orthogonal, but the patterns $AB$, $BC$ e $CD$ are not.
	\end{block}
\end{frame}
\begin{frame}{Considering Pattern Structures}
	\begin{itemize}[<+-| alert@+>]
		\item Let $\I$ be a set of items, $\D$ a dataset of transactions in $\I$, $\F$ the set of frequent patterns in $\D$, and $\Fl$ a sub-set of $\F$ ($\Fl \subseteq \F$);
		\item We say that $\Il \subseteq \I$ is the sub-set of items that appear in, at least, one of the patterns found in $\Fl$;
		\item For each item $i \subseteq \Il$ is given a weight: \[w_i = \frac{|\Fl|-|\Fli|}{|\Fl|-1},\] where $\Fli \subseteq \Fl$ is the sub-set of patterns from $\Fl$ that contains the item $i$;
	\end{itemize}
\end{frame}

\begin{frame}{Considering Pattern Structures}
	\begin{itemize}[<+-| alert@+>]
		\item The orthogonality based in patterns structure for the set is giben by: \[O_e = \frac{\sum_{i \subseteq \Il} w_i}{|\Il|}.\]
	\end{itemize}
\end{frame}

\begin{frame}{Considering Transaction Coverage}
	\begin{block}{Motivação}
		Dois padrões são ortogonais se eles cobrem áreas diferentes da base de dados, ou seja, se os conjuntos de transações cobertas por cada padrão não possuem elementos em comum.
	\end{block}
\end{frame}

\begin{frame}{Considerando Cobertura de Transações}
	\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{../thesis/img/coverage}
	\caption{Visualização de Cobertura de Transações na Base de Dados}
	\label{fig:covex1}
	\end{figure}
\end{frame}

\begin{frame}{Considerando Cobertura de Transações}
	\begin{itemize}[<+-| alert@+>]
		\item Seja $\I$ um conjunto de itens, $\D$ uma base de dados de transações em $\I$, $\F$ o conjunto de padrões freqüentes em $\D$, e $\Fl$ um sub-conjunto de $\F$ ($\Fl \subseteq \F$);
		\item Chamamos de $\Dl \subseteq \D$ o sub-conjunto transações cobertas por, pelo menos, um dos padrões de $\Fl$;
		\item Para cada transação $t \subseteq \Dl$ é dado um peso: \[w_t = \frac{|\Fl| - |\Flt|}{|\Fl| - 1},\] onde $\Flt$ é o sub-conjunto de padrões de $\Fl$ que cobrem a transação $t$;
	\end{itemize}
\end{frame}

\begin{frame}{Considerando Cobertura de Transações}
	\begin{itemize}[<+-| alert@+>]
		\item A ortogonalidade baseada em cobertura de transações do conjunto é dada por: \[O_t = \frac{\sum_{t \subseteq \Dl} w_t}{|\Dl|}.\]
	\end{itemize}
\end{frame}

\begin{frame}{Considerando Cobertura de Classes}
	\begin{block}{Motivação}
		Dois padrões são ortogonais se são encontrados em transações de classes distintas na base de dados, ou seja, os conjuntos de transações cobertas por cada um dos padrões não devem possuir classes em comum.
	\end{block}
\end{frame}

\begin{frame}{Considerando Cobertura de Classes}
	\begin{itemize}[<+-| alert@+>]
		\item Seja $\I$ um conjunto de itens, $\D$ uma base de dados de transações em $\I$, $\F$ o conjunto de padrões freqüentes em $\D$, $\Fl$ um sub-conjunto de $\F$ ($\Fl \subseteq \F$) e $\Dl \subseteq \D$ o sub-conjunto transações cobertas por, pelo menos, um dos padrões de $\Fl$;
		\item Seja $\C$ um conjunto de classes associadas às transações de $\D$ e $\Cl \subseteq \C$ o sub-conjunto de classes associadas às transações de $\Dl$;
		\item Para cada classe $c \subseteq \Cl$ é dado um peso: \[w_c = \frac{|\Fl| - |\Flc|}{|\Fl| - 1},\] onde $\Flc$ é o sub-conjunto de padrões de $\Fl$ que cobrem uma quantidade de transações de classe $c \subseteq \Cl$ maior que $90\%$ da média esperada;		
	\end{itemize}
\end{frame}

%\begin{frame}{Considerando Cobertura de Classes}
%	\begin{itemize}[<+-| alert@+>]
%		\item Para cada classe $c \subseteq \Cl$ é dado um peso: \[w_c = \frac{|\Fl| - |\Flc|}{|\Fl| - 1},\] onde $\Flc$ é o sub-conjunto de padrões de $\Fl$ que cobrem uma quantidade de transações de classe $c \subseteq \Cl$ maior que $90\%$ da média esperada;
%	\end{itemize}
%\end{frame}

\begin{frame}{Considerando Cobertura de Classes}
	\begin{itemize}[<+-| alert@+>]
		\item A ortogonalidade baseada em cobertura de classes é dada por: \[O_c = \frac{\sum_{c \subseteq \Cl} w_c}{|\Cl|}.\]
	\end{itemize}
\end{frame}

\subsection{Classificação Associativa e Ortogonalidade}

\begin{frame}{Utilização da ortogonalidade no LAC}
	\begin{itemize}[<+-| alert@+>]
		\item Para cada instância de teste, o LAC (\textit{Lazy Associative Classifier}) cria uma projeção da base de treinamento apenas com as transações que possuem itens em comum com a instância;
		\item A partir desta projeção, a obtém um conjunto de padrões freqüentes, de acordo com determinado suporte fornecido pelo usuário;
		\item Com estes padrões, gera as regras de associação utilizadas durante a tarefa de classificação.
	\end{itemize}
\end{frame}

\begin{frame}{Utilização da ortogonalidade no LAC}
	\begin{itemize}[<+-| alert@+>]
		\item Neste trabalho, a ortogonalidade foi utilizada para se extrair, do conjunto de padrões freqüentes, um sub-conjunto de padrões ortogonais;
		\item As regras de associação foram geradas a partir do sub-conjunto de padrões ortogonais obtido.
	\end{itemize}
\end{frame}

\begin{frame}{Heurística de Obtenção de Conjuntos Ortogonais}
	\begin{itemize}[<+-| alert@+>]
		\item O problema de se encontrar o sub-conjunto de padrões com maior métrica de ortogonalidade, dado o conjunto de padrões freqüentes, é não polinomial;
		\item Foi desenvolvida uma heurística gulosa que inicia com um conjunto ortogonal de dois elementos, e, iterativamente, tenta obter um novo conjunto com um elemento a mais, acrescentando padrões candidatos e realizando modificações para que a métrica de ortogonalidade seja maximizada.
	\end{itemize}
\end{frame}

\begin{frame}[shrink=5]{Heurística de Obtenção de Conjuntos Ortogonais}
%\begin{frame}{Heurística de Obtenção de Conjuntos Ortogonais}

\begin{algorithm}[H]
\caption{OLAC}
\label{alg:olac}
\begin{algorithmic}[1]

\REQUIRE $\D, \sigma$
	\STATE $\F \leftarrow FindFrequentPatterns (\D, \sigma)$
	\STATE $Sort (\F)$
	\STATE $\Or \leftarrow GetFirstAvailablePattern (\F)$
	\REPEAT
		\STATE $rate \leftarrow GetOrthogonalityRate (\Or)$
%		\STATE $\Or_{try} \leftarrow \Or \cup GetFirstAvailablePattern (\F)$
%		\STATE $rate_{try} = GetOrthogonalityRate (\Or_{try})$
%		\FOR {$P \in \F, P \notin \Or_{try}$}
%			\STATE $S \leftarrow GetMoreSimilar (\Or, P)$
%			\STATE $\Or_{try} \leftarrow \Or_{try} \cup P \ \backslash \ S$
%			\STATE $rate_{tmp} = GetRate (\Or)$
%			\IF {$rate_{tmp} \leq rate_{try}$}
%				\STATE $\Or_{try} \leftarrow \Or_{try} \cup S \  \backslash \  P$
%			\ELSE
%				\STATE $rate_{try} \leftarrow rate_{tmp}$
%			\ENDIF
%		\ENDFOR
		\STATE $\Or_{c} \leftarrow GetNextCandidateSet (\Or, \F)$
		\STATE $rate_{c} = GetOrthogonalityRate (\Or_{c})$
		\IF {$rate_{c} \geq rate$}
			\STATE $\Or \leftarrow \Or_{c}$
		\ENDIF
	\UNTIL {$rate_{c} < rate$}
	\STATE $\R \leftarrow \Or$

\end{algorithmic}
\end{algorithm}

\end{frame}

\begin{frame}[shrink=5]{Heurística de Obtenção de Conjuntos Ortogonais}
%\begin{frame}{Heurística de Obtenção de Conjuntos Ortogonais}

\begin{algorithm}[H]
\caption{OLAC - GetNextCandidateSet}
\label{alg:olac_getNextCandidateSet}
\begin{algorithmic}[1]

\REQUIRE $\Or, \F$
\STATE $\Or_{c} \leftarrow \Or \cup GetFirstAvailablePattern (\F)$
\STATE $rate_{c} = GetOrthogonalityRate (\Or_{c})$
\FOR {$P \in \F, P \notin \Or_{c}$}
	\STATE $S \leftarrow GetMoreSimilar (\Or_{c}, P)$
	\STATE $\Or_{c} \leftarrow \Or_{c} \cup P \ \backslash \ S$
	\STATE $rate_{try} = GetRate (\Or_{c})$
	\IF {$rate_{try} > rate_{c}$}
		\STATE $rate_{c} \leftarrow rate_{try}$
	\ELSE
		\STATE $\Or_{c} \leftarrow \Or_{c} \cup S \  \backslash \  P$
	\ENDIF
\ENDFOR
\RETURN $\Or_{c}$
%
\end{algorithmic}
\end{algorithm}

\end{frame}

\subsection{Estratégia ORIGAMI}

\begin{frame}{Contextualização}
O \textbf{ORIGAMI} é um algoritmo para mineração de grafos encontrado na literatura, onde os autores introduzem a definição de conjuntos $\alpha$-ortogonais e $\beta$-representativos, e apresentam o novo paradigma de mineração de conjuntos de grafos ortogonais com foco nos padrões, e não nas transações.
\end{frame}

\begin{frame}{Definição de $\alpha$-ortogonalidade}
	\begin{itemize}[<+-| alert@+>]
		\item Seja $\F$ o conjunto de todos os sub-grafos freqüentes de uma coleção;
		\item Seja $sim : \F \times \F \rightarrow \left[0, 1\right]$ uma função binária e simétrica que retorna a \textit{similaridade} entre dois grafos;
		\item Dada uma coleção de grafos $\G$, e um limite superior para similaridade $\alpha \in \left[0, 1\right]$, dizemos que o sub-conjunto de grafos $\R \subseteq \G$ é \textbf{$\alpha$-ortogonal} em relação a $\G$ se, e somente se, para quaisquer $G_a, G_b \in \R, sim(G_a, G_b) \leq \alpha$ e para qualquer $G_a \in \R$ e qualquer $G_b \in \G \backslash \R, sim(G_a, G_b) > \alpha$;
	\end{itemize}
\end{frame}

\begin{frame}{Definição de $\alpha$-ortogonalidade}
	\begin{itemize}[<+-| alert@+>]
		\item Dada uma coleção de grafos $\G$,um conjunto $\alpha$-ortogonal $\R \subseteq \G$ e um limite inferior para similaridade $\beta \in \left[0, 1\right]$, dizemos que $\R$ \textbf{representa} um grafo $G \in \G$ se existe algum $G_a \in \R$ tal que $sim(G_a, G) \geq \beta$. Seja $\Upsilon(\R,\G) = \left\{G \in \G : \exists G_a \in \R, sim(G, G_a) \geq \beta\right\}$, dizemos que $\R$ é um conjunto $\beta$-representativo para $\Upsilon(\R, \G)$;
	\end{itemize}
\end{frame}

\begin{frame}{Definição de $\alpha$-ortogonalidade}
	\begin{itemize}[<+-| alert@+>]		
		\item Dada uma coleção de grafos $\G$ e o seu conjunto $\alpha$-ortogonal e $\beta$-representativo $\R$, chamamos de \textbf{resíduo} de $\R$ o conjunto de padrões não representados em $\G$, dado como $\Delta(\R, \G) = \G \backslash \left\{ \R \cup \Upsilon(\R, \G) \right\}$, o \textit{resíduo} de $\R$ é definido como a cardinalidade do seu conjunto resíduo $|\Delta(\R, \G)|$. Finalmente, definimos a média de similaridade do resíduo de $\R$ como $ars(\R, \G) = \frac{\sum_{G_b \in \Delta(\R, \G)} {max_{G_a \in \R} \left\{sim(G_a, G_b)\right\}}}{|\Delta(\R, \G)|}$.
	\end{itemize}
\end{frame}

\begin{frame}{Definição de $\alpha$-ortogonalidade}
	\begin{block}{Objetivo}
		O objetivo é encontrar conjuntos de grafos $\alpha$-ortogonais e $\beta$-representativos em relação ao conjunto de sub-grafos maximais $\M$.
	\end{block}
\end{frame}

\begin{frame}{O Algoritmo ORIGAMI}

\begin{algorithm}[H]
\caption{ORIGAMI}
\label{alg:origami}
\begin{algorithmic}[1]

\REQUIRE $\D, \sigma, \alpha, \beta$
\STATE $EM \leftarrow EdgeMap (\D)$
\STATE $\F_1 \leftarrow FindFrequentEdges (\D, \sigma)$
\STATE $\widehat{\M} \leftarrow 0$
\WHILE {$\neg StopCondition ()$}
	\STATE $M \leftarrow RandomMaximalGraph (\D, \F_1, EM, \sigma)$
	\STATE $\widehat{\M} \leftarrow \widehat{\M} \cup M$
\ENDWHILE
\STATE $\R \leftarrow OrthogonalRepresentativeSets (\widehat{\M}, \alpha, \beta)$

\end{algorithmic}
\end{algorithm}

\end{frame}

\begin{frame}{Adaptação do Algoritmo}
	\begin{itemize}[<+-| alert@+>]
		\item Foi implementada uma adaptação do ORIGAMI para o problema de Classificação Associativa;
		\item Foi implementada uma heurística de obtenção de padrões maximais baseada no trabalho apresentado no artigo;
		\item Foi implementada uma heurística de obtenção do conjunto ortogonal baseada no trabalho apresentado no artigo.
	\end{itemize}
\end{frame}

\begin{frame}{Heurística de Obtenção de Padrões Maximais}
	\begin{itemize}[<+-| alert@+>]
		\item O algoritmo inicia a execução com o conjunto-resultado vazio;
		\item A cada iteração, tenta obter o maior padrão freqüente possível, selecionando itens aleatoriamente;
			\begin{itemize}[<+-| alert@+>]
				\item Se o algoritmo escolhe um item já utilizado, ou que produz um padrão não freqüente, um contador de tentativas é decrementado;
				\item A condição de parada para a geração do padrão maximal candidato é que o número de escolhas erradas do item não deve ser maior que o tamanho da instância de teste.
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Heurística de Obtenção de Padrões Maximais}
	\begin{itemize}[<+-| alert@+>]
		\item Ao obter um novo padrão maximal, o algoritmo tenta inseri-lo no conjunto-solução;
		\begin{itemize}[<+-| alert@+>]
			\item Se o padrão escolhido já existe no conjunto, o algoritmo incrementa um segundo contador de tentativas;
			\item A condição de parada para a obtenção de padrões maximais é que o número de padrões candidatos não maximais ou já conhecidos não deve ser superior ao tamanho da instância de teste.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Heurística de Obtenção do Conjunto Ortogonal}
	\begin{itemize}[<+-| alert@+>]
		\item O algoritmo inicia a execução com o valor de resíduo igual a $0$ (zero);
		\item A cada iteração, tenta obter um novo conjunto ortogonal selecionando, aleatoriamente, padrões maximais encontrados na primeira fase do algoritmo, e adicionando-os ao conjunto-solução;
		\begin{itemize}[<+-| alert@+>]
			\item Se, durante a obtenção dos padrões, o padrão selecionado já ter sido utilizado, ou não possuir similaridade menor que $\alpha$ para com todos os outros padrões do conjunto-solução, o algoritmo decrementa um contador de tentativas;
			\item A condição de parada local para a geração de conjuntos ortogonais é que, durante este processo, o número máximo de escolhas erradas de padrões não pode ser maior que a quantidade de padrões maximais total.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Heurística de Obtenção do Conjunto Ortogonal}
	\begin{itemize}[<+-| alert@+>]		
		\item Ao obter um novo conjunto ortogonal, o algoritmo calcula o valor do seu resíduo;
		\item Se este valor é menor que o atual, o resíduo é atualizado, e o conjunto-solução passa a ser o conjunto ortogonal recém-encontrado;
		\item A condição de parada para o algoritmo é que, durante todo o processo, o número máximo de conjuntos ortogonais candidatos que não melhoram o resultado não pode ser maior que a quantidade de padrões maximais total.
	\end{itemize}
\end{frame}


%\begin{frame}{Heurística de Obtenção de Conjuntos Ortogonais}
%	\begin{itemize}[<+-| alert@+>]
%		\item No início do algoritmo, o conjunto-solução é inicializado com apenas um elemento, e a métrica de ortogonalidade do conjunto com o valor $0$ (zero), e então começa o ciclo de iterações:
%		\begin{enumerate}[<+-| alert@+>]
%			\item Um novo elemento é incluído ao conjunto;
%			\item É realizada uma busca por todo o conjunto de padrões que não fazem parte do conjunto-solução. Durante este procedimento, cada padrão verificado é incluído na solução, substituindo, neste conjunto, o elemento que mais se assemelha àquele. Se a métrica de ortogonalidade do conjunto melhorou, o algoritmo mantém a troca. Se não, a troca é desfeita, e o próximo padrão da seqüência é verificado;
%			\item Ao final do processo, o algoritmo compara a métrica de ortogonalidade obtida com a métrica do conjunto anterior (que possuía um elemento a menos). Se a métrica se manteve, ou melhorou, o algoritmo mantém o novo conjunto como solução, e volta ao início do ciclo. Se não, o algoritmo termina o ciclo, e o conjunto anterior é dado como resultado.
%		\end{enumerate}
%	\end{itemize}
%\end{frame}


% Métricas de Ortogonalidade
% Classificação Associativa e Ortogonalidade
% Estratégia ORIGAMI
